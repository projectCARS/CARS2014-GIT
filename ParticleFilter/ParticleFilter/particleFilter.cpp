
#include "definitions.h"
#include "CTModel.h"
#include <Eigen/Dense>
#include "headers.h"
#include "ParticleFilter.h"
#include "Filter.h"

ParticleFilter::ParticleFilter(Eigen::MatrixXf ID, float speed, int lim, MotionModelType::Enum motionModelType)
{
    carPattern = ID;
    expectedSpeed = speed;
    limit = lim;
    noCar = true;
}

ParticleFilter::~ParticleFilter()
{
}

void ParticleFilter::setState(float state[3])
{
<<<<<<< HEAD
    for (int i = 0; i < NUMBER_OF_PARTICLES; i++)
=======
	ParticleFilter::ParticleFilter(Eigen::MatrixXf ID, float speed, int lim, MotionModelType::Enum motionModelType)
	{
		carPattern = ID;
		expectedSpeed = speed;
		limit = lim;
		noCar = true;
        
        switch (motionModelType)
        {
            default:
                //Use random Walk
        }
	}

	ParticleFilter::~ParticleFilter()
	{
	}
    
	void ParticleFilter::setState(float state[3])
	{
		for (int i = 0; i < NUMBER_OF_PARTICLES; i++)
		{
			posX[i] = state[0];
			posY[i] = state[1];
			yaw[i] = state[2];
		}
	}

	void ParticleFilter::propagate(void)
	{
		for (int i = 0; i < NUMBER_OF_PARTICLES; i++)
		{
			// update points with random walk model
			float speed = expectedSpeed + 20 * gaussianNoise();
			yawPoints[i] = yaw[i] + M_PI / 5 * gaussianNoise(); // angle
			posXPoints[i] = posX[i] + speed*sin(yawPoints[i]);
			posYPoints[i] = posY[i] - speed*cos(yawPoints[i]); // note negative Y - direction with pixel coordinates

		}
	}

	float ParticleFilter::gaussianNoise(void)
	{
		static float rand1, rand2;

		rand1 = rand() / ((float)RAND_MAX);
		// Something not to small, since it's stored as a float
		if (rand1 < 1e-20)
		{
			rand1 = 1e-20;
		}
		rand1 = -2 * log(rand1);
		rand2 = (rand() / ((float)RAND_MAX)) * 2 * M_PI;

		return sqrt(rand1) * cos(rand2);
	}

	void ParticleFilter::update(const cv::Mat img)
	{
		// Add border values around each point controlled
		cv::Rect ROI = cv::Rect(0, 0, limit, limit);
		cv::Mat imgROI(limit, limit, CV_8UC1, cv::Scalar(0, 0, 0));

		int points = carPattern.rows();
		Eigen::Matrix2f rotate, translate;
		Eigen::MatrixXf pos;
		Eigen::MatrixXf ones = Eigen::MatrixXf::Ones(2, points);
		float val, sum, x = 0, y = 0;
		float totSum = 0.;
		for (int n = 0; n < NUMBER_OF_PARTICLES; n++)
		{
			// Rotate and translate pattern according to hypothesis
			rotate << cos(yawPoints[n]), -sin(yawPoints[n]),
				sin(yawPoints[n]), cos(yawPoints[n]);
			translate << posXPoints[n], 0,
				posYPoints[n], 0;
			pos = rotate*carPattern.transpose() + translate*ones;

			val = 0.;
			sum = 0.;
			for (int p = 0; p < points; p++)
			{
				// Update ROI
				ROI.x = pos(0, p);
				ROI.y = pos(1, p);
				//std::cout << "checking: [" << ROI.x << ", " << ROI.y << std::endl;
				if (ROI.x - limit > 0 && ROI.x + limit < img.cols && ROI.y - limit > 0 && ROI.y + limit < img.rows)
				{
					imgROI = img(ROI);
					cv::Scalar mean = cv::mean(imgROI);

					// Throws the hypothesis if no point found.This gives some speedup.
					if (mean.val[0] == 0)
					{
						//totSum = 0;
						sum = 0;
						break;
					}
					else
					{
						sum += mean.val[0];
                        
					}


				}
			}
			totSum += sum;
			cumulativeWeights[n] = totSum; // save weights cumulative sum for later normalization
		}



	}

	void ParticleFilter::resample(void)
	{
		// randomly, uniformally, sample from the cummulative distribution of the probability distribution generated by the
		// weighted vector 'weight'.
		float randNo;
		int index = 0;
		sumStates[0] = 0;
		sumStates[1] = 0;
		sumStates[2] = 0;
		if (cumulativeWeights[NUMBER_OF_PARTICLES - 1] != 0)
		{
			// Normalize weights to form a cumulative summed probability distribution
			for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
			{
				cumulativeWeights[i] /= cumulativeWeights[NUMBER_OF_PARTICLES - 1];
			}

			for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
			{
				randNo = rand() / ((float)RAND_MAX);
				index = findFirst(randNo);
				posX[i] = posXPoints[index];
				sumStates[0] += posXPoints[index];

				posY[i] = posYPoints[index];
				sumStates[1] += posYPoints[index];

				yaw[i] = yawPoints[index];
				sumStates[2] += yawPoints[index];
			}
		}
		else
		{
			noCar = true;
			/*
			// try to save the situation with model
			for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
			{
			posX[i] = posXPoints[i];
			sumStates[0] += posXPoints[i];

			posY[i] = posYPoints[i];
			sumStates[1] += posYPoints[i];

			yaw[i] = yawPoints[i];
			sumStates[2] += yawPoints[i];
			}
			*/
		}
	}
    
    void ParticleFilter::systematicResample(void)
>>>>>>> parent of 69c9a8d... Revert "PFmod"
    {
        posX[i] = state[0];
        posY[i] = state[1];
        yaw[i] = state[2];
    }
}

void ParticleFilter::propagate(void)
{
    for (int i = 0; i < NUMBER_OF_PARTICLES; i++)
    {
        // update points with random walk model
        float speed = expectedSpeed + 20 * gaussianNoise();
        yawPoints[i] = yaw[i] + M_PI / 5 * gaussianNoise(); // angle
        posXPoints[i] = posX[i] + speed*sin(yawPoints[i]);
        posYPoints[i] = posY[i] - speed*cos(yawPoints[i]); // note negative Y - direction with pixel coordinates

    }
}

float ParticleFilter::gaussianNoise(void)
{
    static float rand1, rand2;

    rand1 = rand() / ((float)RAND_MAX);
    // Something not to small, since it's stored as a float
    if (rand1 < 1e-20)
    {
        rand1 = 1e-20;
    }
    rand1 = -2 * log(rand1);
    rand2 = (rand() / ((float)RAND_MAX)) * 2 * M_PI;

    return sqrt(rand1) * cos(rand2);
}

void ParticleFilter::update(const cv::Mat img)
{
    // Add border values around each point controlled
    cv::Rect ROI = cv::Rect(0, 0, limit, limit);
    cv::Mat imgROI(limit, limit, CV_8UC1, cv::Scalar(0, 0, 0));

    int points = carPattern.rows();
    Eigen::Matrix2f rotate, translate;
    Eigen::MatrixXf pos;
    Eigen::MatrixXf ones = Eigen::MatrixXf::Ones(2, points);
    float val, sum, x = 0, y = 0;
    float totSum = 0.;
    for (int n = 0; n < NUMBER_OF_PARTICLES; n++)
    {
        // Rotate and translate pattern according to hypothesis
        rotate << cos(yawPoints[n]), -sin(yawPoints[n]),
                sin(yawPoints[n]), cos(yawPoints[n]);
        translate << posXPoints[n], 0,
                posYPoints[n], 0;
        pos = rotate*carPattern.transpose() + translate*ones;

        val = 0.;
        sum = 0.;
        for (int p = 0; p < points; p++)
        {
            // Update ROI
            ROI.x = pos(0, p);
            ROI.y = pos(1, p);
            //std::cout << "checking: [" << ROI.x << ", " << ROI.y << std::endl;
            if (ROI.x - limit > 0 && ROI.x + limit < img.cols && ROI.y - limit > 0 && ROI.y + limit < img.rows)
            {
<<<<<<< HEAD
                imgROI = img(ROI);
                cv::Scalar mean = cv::mean(imgROI);

                // Throws the hypothesis if no point found.This gives some speedup.
                if (mean.val[0] == 0)
                {
                    //totSum = 0;
                    sum = 0;
                    break;
                }
                else
                {
                    sum += mean.val[0];
                }


=======
                cumulativeWeights[i] /= cumulativeWeights[NUMBER_OF_PARTICLES - 1];
                ordNum[i+1] = ((i + 1) + (rand() / ((float)RAND_MAX)))/NUMBER_OF_PARTICLES
            }
            cumulativeWeights[i + 1] /= cumulativeWeights[NUMBER_OF_PARTICLES - 1];
            
            int k = 0;
            
            for(int j = 0; j < NUMBER_OF_PARTICLES - 1; j++){
                
                while(cumulativeWeights[k] < ordNum[j])
                    k++;
                posX[j] = posXPoints[k];
                posY[j] = posYPoints[k];
                yaw[j] = yawPoints[k];
                
                sumStates[0] += posXPoints[k];
                sumStates[1] += posYPoints[k];
                sumStates[2] += yawPoints[k];
>>>>>>> parent of 69c9a8d... Revert "PFmod"
            }
        }
        totSum += sum;
        cumulativeWeights[n] = totSum; // save weights cumulative sum for later normalization
    }



}

void ParticleFilter::resample(void)
{
    // randomly, uniformally, sample from the cummulative distribution of the probability distribution generated by the
    // weighted vector 'weight'.
    float randNo;
    int index = 0;
    sumStates[0] = 0;
    sumStates[1] = 0;
    sumStates[2] = 0;
    if (cumulativeWeights[NUMBER_OF_PARTICLES - 1] != 0)
    {
        // Normalize weights to form a cumulative summed probability distribution
        for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
        {
            cumulativeWeights[i] /= cumulativeWeights[NUMBER_OF_PARTICLES - 1];
        }

        for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
        {
            randNo = rand() / ((float)RAND_MAX);
            index = findFirst(randNo);
            posX[i] = posXPoints[index];
            sumStates[0] += posXPoints[index];

            posY[i] = posYPoints[index];
            sumStates[1] += posYPoints[index];

            yaw[i] = yawPoints[index];
            sumStates[2] += yawPoints[index];
        }
    }
    else
    {
        noCar = true;
        /*
            // try to save the situation with model
            for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
            {
            posX[i] = posXPoints[i];
            sumStates[0] += posXPoints[i];

            posY[i] = posYPoints[i];
            sumStates[1] += posYPoints[i];

            yaw[i] = yawPoints[i];
            sumStates[2] += yawPoints[i];
            }
            */
    }
}

void ParticleFilter::systematicResample(void)
{
    // randomly, uniformally, sample from the cummulative distribution of the probability distribution generated by the
    // weighted vector 'weight'.
    float randNo;
    float ordNum[NUMBER_OF_PARTICLES];
    int index = 0;
    sumStates[0] = 0;
    sumStates[1] = 0;
    sumStates[2] = 0;

    if (cumulativeWeights[NUMBER_OF_PARTICLES - 1] != 0)
    {
        ordNum[0] = (rand() / ((float)RAND_MAX))/NUMBER_OF_PARTICLES;

        // Normalize weights to form a cumulative summed probability distribution
        for (int i = 0; i < NUMBER_OF_PARTICLES - 1; ++i)
        {
            cumulativeWeights[i] /= cumulativeWeights[NUMBER_OF_PARTICLES - 1];
            ordNum[i + 1] = ((i + 1) + (rand() / ((float)RAND_MAX))) / NUMBER_OF_PARTICLES;
        }
        cumulativeWeights[NUMBER_OF_PARTICLES - 1] /= cumulativeWeights[NUMBER_OF_PARTICLES - 1];

        int k = 0;

        for(int j = 0; j < NUMBER_OF_PARTICLES - 1; j++){

            while(cumulativeWeights[k] < ordNum[j])
                k++;
            posX[j] = posXPoints[k];
            posY[j] = posYPoints[k];
            yaw[j] = yawPoints[k];
        }

    }
    else
    {
        noCar = true;
        /*
             // try to save the situation with model
             for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
             {
             posX[i] = posXPoints[i];
             sumStates[0] += posXPoints[i];
             
             posY[i] = posYPoints[i];
             sumStates[1] += posYPoints[i];
             
             yaw[i] = yawPoints[i];
             sumStates[2] += yawPoints[i];
             }
             */
    }
}

int ParticleFilter::findFirst(const float value)
{
    for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
    {
        if (cumulativeWeights[i] >= value)
        {
            return i;
        }
    }
    std::cout << "Class ParticleFilter:	Error in findFirst()" << std::endl;
    //std::cout << "Class ParticleFilter:	Trying to find > " << value << "in array with max " << cumulativeWeights[NUMBER_OF_PARTICLES - 1] << std::endl;
    return -1;
}

void ParticleFilter::logStates(std::ofstream *logFile)
{
    *logFile << sumStates[0] / NUMBER_OF_PARTICLES << " " << sumStates[1] / NUMBER_OF_PARTICLES << " " << sumStates[2] / NUMBER_OF_PARTICLES << std::endl;
}

void ParticleFilter::extensiveSearch(cv::Mat img)
{
    // Detect contrasting image features for seeding states
    cv::vector<cv::vector<cv::Point> > contours;
    cv::vector<cv::Vec4i> hierarchy;
    findContours(img, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0));

    // Merge connected components
    int i, j;
    std::vector<cv::Point> blobs;
    if (!contours.empty())
    {
        for (i = 0; i < contours.size(); i++)
        {
            int x = 0;
            int y = 0;
            int len = contours.at(i).size();
            // naive approach by averaging contour points
            for (j = 0; j < len; j++)
            {
                //std::cout << "in component " << i << ", [" << contours.at(i).at(j).x << ", " << contours.at(i).at(j).y << "]" << std::endl;
                x += contours.at(i).at(j).x;
                y += contours.at(i).at(j).y;
            }
            cv::Point point;
            point.x = x / len;
            point.y = y / len;
            blobs.push_back(point);
        }
    }
    else
    {
        std::cout << "Class ParticleFilter:	Cannot find any image features in extensive search" << std::endl;
    }

    int index;
    float yawGuess;
    if (!contours.empty()) // Guess position based on image features
    {
        for (int i = 0; i < NUMBER_OF_PARTICLES; i++)
        {
            yawGuess = (rand() / ((float)RAND_MAX))*M_PI * 2; // pick any angle

            // Feed image feature points + guessed yaw to state vectors
            yaw[i] = yawGuess;
            index = rand() % blobs.size(); // pick one of the probable points;
            posX[i] = blobs[index].x;
            posY[i] = blobs[index].y;
        }
    }
    else // Look over entire image
    {
        for (int i = 0; i < NUMBER_OF_PARTICLES; i++)
        {
            posX[i] = (rand() / ((float)RAND_MAX))*img.cols; // pick any posX
            posY[i] = (rand() / ((float)RAND_MAX))*img.rows; // pick any posY
            yaw[i] = (rand() / ((float)RAND_MAX))*M_PI * 2; // pick any angle
        }
    }
    noCar = false; // To break extensive search. This will be tried on next image search.
}

void ParticleFilter::addMeasurement2(const cv::Mat img)
{
    m_img = img;
    // Set measurement boolean to true (we just recieved new measurements).
    m_newMeasurement = true;
}

void ParticleFilter::addInputSignals(float gas, float turn)
{
    //Add control signals to filter.
    float u = gas;
}

std::vector<float> ParticleFilter::getState(void)
{
    std::vector<float> state(xhat.size());
    for (int i=0; i < xhat.size(); i++)
    {
        state[i] = xhat[i];
    }
    return state;
}

void ParticleFilter::updateFilter()
{
    if (particleFilter.carGone())
    {
        std::cout << "Class ParticleFilter:	Could not find any matching hypotheses. Attempting extensive search" << std::endl;
        particleFilter.extensiveSearch(img);
    }
    else
    {
        particleFilter.propagate();
        particleFilter.update(img);
        particleFilter.resample();
    }
}

void ParticleFilter::addMeasurement(float x, float y, float theta)
{
    /* Add measurements to the filter. We assume here that all motion models
        measure x, y and theta. */
    // Set measurement boolean to true (we just recieved new measurements).
    m_newMeasurement = true;
}

<<<<<<< HEAD
=======
	int ParticleFilter::findFirst(const float value)
	{
		for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
		{
			if (cumulativeWeights[i] >= value)
			{
				return i;
			}
		}
		std::cout << "Class ParticleFilter:	Error in findFirst()" << std::endl;
		//std::cout << "Class ParticleFilter:	Trying to find > " << value << "in array with max " << cumulativeWeights[NUMBER_OF_PARTICLES - 1] << std::endl;
		return -1;
	}

	void ParticleFilter::logStates(std::ofstream *logFile)
	{
		*logFile << sumStates[0] / NUMBER_OF_PARTICLES << " " << sumStates[1] / NUMBER_OF_PARTICLES << " " << sumStates[2] / NUMBER_OF_PARTICLES << std::endl;
	}

	void ParticleFilter::extensiveSearch(cv::Mat img)
	{
		// Detect contrasting image features for seeding states
		cv::vector<cv::vector<cv::Point> > contours;
		cv::vector<cv::Vec4i> hierarchy;
		findContours(img, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0));

		// Merge connected components
		int i, j;
		std::vector<cv::Point> blobs;
		if (!contours.empty())
		{
			for (i = 0; i < contours.size(); i++)
			{
				int x = 0;
				int y = 0;
				int len = contours.at(i).size();
				// naive approach by averaging contour points
				for (j = 0; j < len; j++)
				{
					//std::cout << "in component " << i << ", [" << contours.at(i).at(j).x << ", " << contours.at(i).at(j).y << "]" << std::endl;
					x += contours.at(i).at(j).x;
					y += contours.at(i).at(j).y;
				}
				cv::Point point;
				point.x = x / len;
				point.y = y / len;
				blobs.push_back(point);
			}
		}
		else
		{
			std::cout << "Class ParticleFilter:	Cannot find any image features in extensive search" << std::endl;
		}

		int index;
		float yawGuess;
		if (!contours.empty()) // Guess position based on image features
		{
			for (int i = 0; i < NUMBER_OF_PARTICLES; i++)
			{
				yawGuess = (rand() / ((float)RAND_MAX))*M_PI * 2; // pick any angle

				// Feed image feature points + guessed yaw to state vectors
				yaw[i] = yawGuess;
				index = rand() % blobs.size(); // pick one of the probable points;
				posX[i] = blobs[index].x;
				posY[i] = blobs[index].y;
			}
		}
		else // Look over entire image
		{
			for (int i = 0; i < NUMBER_OF_PARTICLES; i++)
			{
				posX[i] = (rand() / ((float)RAND_MAX))*img.cols; // pick any posX
				posY[i] = (rand() / ((float)RAND_MAX))*img.rows; // pick any posY
				yaw[i] = (rand() / ((float)RAND_MAX))*M_PI * 2; // pick any angle
			}
		}
		noCar = false; // To break extensive search. This will be tried on next image search.
	}
}



virtual void ParticleFilter::addMeasurement(const cv::Mat img){
    m_img = img;
    m_newMeasurement = true;
}

// Add a new set of inputsignals to the filter
virtual void addInputSignals(float gas, float turn){
    u(0) = gas;
    u(1) = turn;
}

// Create new state estimates.
virtual void updateFilter()
{
    if (particleFilter.carGone())
    {
        std::cout << "Class ParticleFilter:	Could not find any matching hypotheses. Attempting extensive search" << std::endl;
        particleFilter.extensiveSearch(img);
    }
    else
    {
        particleFilter.propagate();
        particleFilter.update(m_img);
        particleFilter.resample();
    }

}

// Get current state estimets.
virtual std::vector<float> getState()
{
    std::vector<float> state(xhat.size());
    for(int i = 0; i < xhat.size(); i++){
        state[i] = xhat[i];
    }
    return state;
}




>>>>>>> parent of 69c9a8d... Revert "PFmod"
