
#include "definitions.h"
#include "headers.h"
#include "ParticleFilter.h"
#include "Filter.h"
#include "CTModel.h"
#include <Eigen/Dense>
#include <math.h>
#include <QDebug>

    ParticleFilter::ParticleFilter(Eigen::MatrixXf ID, float speed, int lim, MotionModelType::Enum motionModelType)
    {
        switch (motionModelType)
        {
            case MotionModelType::CTModel:
                M = new CTModel();
                break;
            default:
                std::cout << "Error: Motion model type not implemented, in EKF::EKF(), EKF.cpp" << std::endl;
        }

        carPattern = ID;
        expectedSpeed = speed;
        limit = lim;
        noCar = true;
        xhat = VectorXd::Zero(M->getNumStates());
        sumStates[0] = 0;
        sumStates[1] = 0;
        sumStates[2] = 0;
        m_img = cv::imread("indata/ImageWithCar.jpg", CV_LOAD_IMAGE_GRAYSCALE);
    }

    ParticleFilter::~ParticleFilter()
    {
    }

    void ParticleFilter::setState(float state[3])
    {
        for (int i = 0; i < NUMBER_OF_PARTICLES; i++)
        {
            posX[i] = state[0];
            posY[i] = state[1];
            yaw[i] = state[3];
        }
    }

    void ParticleFilter::propagate(void)
    {
        for (int i = 0; i < NUMBER_OF_PARTICLES; i++)
        {
            // update points with random walk model
            float speed = expectedSpeed + 20 * gaussianNoise();
            yawPoints[i] = yaw[i] + M_PI / 5 * gaussianNoise(); // angle
            posXPoints[i] = posX[i] + speed*sin(yawPoints[i]);
            posYPoints[i] = posY[i] - speed*cos(yawPoints[i]); // note negative Y - direction with pixel coordinates

        }
    }

    float ParticleFilter::gaussianNoise(void)
    {
        static float rand1, rand2;

        rand1 = rand() / ((float)RAND_MAX);
        // Something not to small, since it's stored as a float
        if (rand1 < 1e-20)
        {
            rand1 = 1e-20;
        }
        rand1 = -2 * log(rand1);
        rand2 = (rand() / ((float)RAND_MAX)) * 2 * M_PI;

        return sqrt(rand1) * cos(rand2);
    }

    void ParticleFilter::update(const cv::Mat img)
    {
        // Add border values around each point controlled
        cv::Rect ROI = cv::Rect(0, 0, limit, limit);
        cv::Mat imgROI(limit, limit, CV_8UC1, cv::Scalar(0, 0, 0));

        int points = carPattern.rows();
        Eigen::Matrix2f rotate, translate;
        Eigen::MatrixXf pos;
        Eigen::MatrixXf ones = Eigen::MatrixXf::Ones(2, points);
        float val, sum, x = 0, y = 0;
        float totSum = 0.;
        for (int n = 0; n < NUMBER_OF_PARTICLES; n++)
        {
            // Rotate and translate pattern according to hypothesis
            rotate << cos(yawPoints[n]), -sin(yawPoints[n]),
                sin(yawPoints[n]), cos(yawPoints[n]);
            translate << posXPoints[n], 0,
                posYPoints[n], 0;
            pos = rotate*carPattern.transpose() + translate*ones;

            val = 0.;
            sum = 0.;
            for (int p = 0; p < points; p++)
            {
                // Update ROI
                ROI.x = pos(0, p);
                ROI.y = pos(1, p);
                //std::cout << "checking: [" << ROI.x << ", " << ROI.y << std::endl;
                if (ROI.x - limit > 0 && ROI.x + limit < img.cols && ROI.y - limit > 0 && ROI.y + limit < img.rows)
                {
                    imgROI = img(ROI);
                    cv::Scalar mean = cv::mean(imgROI);

                    // Throws the hypothesis if no point found.This gives some speedup.
                    if (mean.val[0] == 0)
                    {
                        //totSum = 0;
                        sum = 0;
                        break;
                    }
                    else
                    {
                        sum += mean.val[0];
                    }


                }
            }
            totSum += sum;
            cumulativeWeights[n] = totSum; // save weights cumulative sum for later normalization
        }



    }

    void ParticleFilter::resample(void)
    {
        // randomly, uniformally, sample from the cummulative distribution of the probability distribution generated by the
        // weighted vector 'weight'.
        float randNo;
        int index = 0;
        sumStates[0] = 0;
        sumStates[1] = 0;
        sumStates[2] = 0;
        sumStates[3] = 0;
        sumStates[4] = 0;
        if (cumulativeWeights[NUMBER_OF_PARTICLES - 1] != 0)
        {
            // Normalize weights to form a cumulative summed probability distribution
            for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
            {
                cumulativeWeights[i] /= cumulativeWeights[NUMBER_OF_PARTICLES - 1];
            }

            for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
            {
                randNo = rand() / ((float)RAND_MAX);
                index = findFirst(randNo);
                posX[i] = posXPoints[index];
                sumStates[0] += posXPoints[index];

                posY[i] = posYPoints[index];
                sumStates[1] += posYPoints[index];

                yaw[i] = yawPoints[index];
                sumStates[3] += yawPoints[index];
            }
        }
        else
        {
            noCar = true;
            /*
            // try to save the situation with model
            for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
            {
            posX[i] = posXPoints[i];
            sumStates[0] += posXPoints[i];

            posY[i] = posYPoints[i];
            sumStates[1] += posYPoints[i];

            yaw[i] = yawPoints[i];
            sumStates[2] += yawPoints[i];
            }
            */
        }
    }

    void ParticleFilter::systematicResample(void)
    {
        // randomly, uniformally, sample from the cummulative distribution of the probability distribution generated by the
        // weighted vector 'weight'.
        float ordNum[NUMBER_OF_PARTICLES];
        sumStates[0] = 0;
        sumStates[1] = 0;
        sumStates[2] = 0;
        sumStates[3] = 0;
        sumStates[4] = 0;
        int k = 0;

        if (cumulativeWeights[NUMBER_OF_PARTICLES - 1] != 0)
        {
            ordNum[0] = (rand() / ((float)RAND_MAX))/NUMBER_OF_PARTICLES;

            // Normalize weights to form a cumulative summed probability distribution
            for (int i = 0; i < NUMBER_OF_PARTICLES - 1; ++i)
            {
                cumulativeWeights[i] /= cumulativeWeights[NUMBER_OF_PARTICLES - 1];
                ordNum[i + 1] = ((i + 1) + (rand() / ((float)RAND_MAX))) / NUMBER_OF_PARTICLES;
            }
            cumulativeWeights[NUMBER_OF_PARTICLES - 1] /= cumulativeWeights[NUMBER_OF_PARTICLES - 1];

            k = 0;

            for(int j = 0; j < NUMBER_OF_PARTICLES - 1; j++){

                while(cumulativeWeights[k] < ordNum[j])
                    k++;
                posX[j] = posXPoints[k];
                posY[j] = posYPoints[k];
                yaw[j] = yawPoints[k];
            }

        }
        else
        {
            noCar = true;
            /*
             // try to save the situation with model
             for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
             {
             posX[i] = posXPoints[i];
             sumStates[0] += posXPoints[i];

             posY[i] = posYPoints[i];
             sumStates[1] += posYPoints[i];

             yaw[i] = yawPoints[i];
             sumStates[2] += yawPoints[i];
             }
             */
        }
    }

    int ParticleFilter::findFirst(const float value)
    {
        for (int i = 0; i < NUMBER_OF_PARTICLES; ++i)
        {
            if (cumulativeWeights[i] >= value)
            {
                return i;
            }
        }
        std::cout << "Class ParticleFilter:	Error in findFirst()" << std::endl;
        //std::cout << "Class ParticleFilter:	Trying to find > " << value << "in array with max " << cumulativeWeights[NUMBER_OF_PARTICLES - 1] << std::endl;
        return -1;
    }

    void ParticleFilter::logStates(std::ofstream *logFile)
    {
        *logFile << sumStates[0] / NUMBER_OF_PARTICLES << " " << sumStates[1] / NUMBER_OF_PARTICLES << " " << sumStates[3] / NUMBER_OF_PARTICLES << std::endl;
    }

    void ParticleFilter::extensiveSearch(cv::Mat img)
    {
        // Detect contrasting image features for seeding states
        cv::vector<cv::vector<cv::Point> > contours;
        cv::vector<cv::Vec4i> hierarchy;
        findContours(img, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0));
        // Merge connected components
        int i, j;
        std::vector<cv::Point> blobs;
        if (!contours.empty())
        {
            for (i = 0; i < contours.size(); i++)
            {
                int x = 0;
                int y = 0;
                int len = contours.at(i).size();
                // naive approach by averaging contour points
                for (j = 0; j < len; j++)
                {
                    //std::cout << "in component " << i << ", [" << contours.at(i).at(j).x << ", " << contours.at(i).at(j).y << "]" << std::endl;
                    x += contours.at(i).at(j).x;
                    y += contours.at(i).at(j).y;
                }

                cv::Point point;
                point.x = x / len;
                point.y = y / len;
                blobs.push_back(point);
            }
        }
        else
        {
            std::cout << "Class ParticleFilter:	Cannot find any image features in extensive search" << std::endl;
        }

        int index;
        float yawGuess;
        if (!contours.empty()) // Guess position based on image features
        {
            for (int i = 0; i < NUMBER_OF_PARTICLES; i++)
            {
                yawGuess = (rand() / ((float)RAND_MAX))*M_PI * 2; // pick any angle

                // Feed image feature points + guessed yaw to state vectors
                yaw[i] = yawGuess;
                index = rand() % blobs.size(); // pick one of the probable points;
                posX[i] = blobs[index].x;
                posY[i] = blobs[index].y;
            }
        }
        else // Look over entire image
        {
            for (int i = 0; i < NUMBER_OF_PARTICLES; i++)
            {
                posX[i] = (rand() / ((float)RAND_MAX))*img.cols; // pick any posX
                posY[i] = (rand() / ((float)RAND_MAX))*img.rows; // pick any posY
                yaw[i] = (rand() / ((float)RAND_MAX))*M_PI * 2; // pick any angle
            }
        }
        noCar = false; // To break extensive search. This will be tried on next image search.
    }

void ParticleFilter::addMeasurement2(const cv::Mat img)
{
    img.copyTo(m_img);
    // Set measurement boolean to true (we just recieved new measurements).
    m_newMeasurement = true;
}



void ParticleFilter::addInputSignals(float gas, float turn)
{
    //Add control signals to filter.
   // float u = gas;
}

std::vector<float> ParticleFilter::getState(void)
{
    std::vector<float> state(xhat.size());
    for (int i=0; i < xhat.size(); i++)
    {
        state[i] = sumStates[i]/NUMBER_OF_PARTICLES;
    }
    state[2] = 0.25;
    return state;
}

void ParticleFilter::updateFilter()
{
    if (carGone())
    {
        std::cout << "Class ParticleFilter:	Could not find any matching hypotheses. Attempting extensive search" << std::endl;
        extensiveSearch(m_img);
    }
    else
    {
        propagate();
        update(m_img);
        resample();
    }
    drawThreadData.sumStates = getSumStates();
}

void ParticleFilter::addMeasurement(float x, float y, float theta)
{
    /* Add measurements to the filter. We assume here that all motion models
        measure x, y and theta. */
    // Set measurement boolean to true (we just recieved new measurements).
    m_newMeasurement = true;
}

void ParticleFilter::addImageMeasurement(cv::Mat img)
{
    img.copyTo(m_img);
    m_newMeasurement = true;
}

